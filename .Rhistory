left_join(pop_data,
by=c("start_district_name"="Gemeinde_n")) %>%
select(start_district_name, end_district_name, count, pop) %>%
mutate(countByPop = count/pop)
tvz_matrix <- trips %>% #build a start-end-matrix
group_by(start_district_name, end_district_name) %>%
summarize(count = n()) %>%
ungroup()
View(tvz_matrix)
tvz_matrix <- tvz_matrix %>% # computing mobility rate
left_join(pop_data,
by=c("start_district_name"="Gemeinde_n")) %>%
select(start_district_name, end_district_name, count, pop) %>%
group_by(start_district_name) %>%
mutate(rate = sum(count) / pop)
tvz_matrix <- tvz_matrix %>% # computing mobility rate
left_join(pop_data,
by=c("start_district_name"="Gemeinde_n")) %>%
select(start_district_name, end_district_name, count, pop) %>%
group_by(start_district_name) %>%
mutate(rate = sum(count) / pop,
totalCount = sum(count))
tvz_matrix <- trips %>% #build a start-end-matrix
group_by(start_district_name, end_district_name) %>%
summarize(count = n()) %>%
ungroup()
tvz_matrix <- tvz_matrix %>% # computing sum of trips per district, mobility rate
left_join(pop_data,
by=c("start_district_name"="Gemeinde_n")) %>%
select(start_district_name, end_district_name, count, pop) %>%
group_by(start_district_name) %>%
mutate(rate = sum(count) / pop,
totalCount = sum(count))
tvz_matrix <- tvz_matrix %>% # computing sum of trips per district, mobility rate
left_join(pop_data,
by=c("start_district_name"="Gemeinde_n")) %>%
select(start_district_name, end_district_name, count, pop) %>%
group_by(start_district_name) %>%
mutate(totalCount = sum(count),
rate = sum(count) / pop)
tvz_matrix <- trips %>% #build a start-end-matrix
group_by(start_district_name, end_district_name) %>%
summarize(count = n()) %>%
ungroup()
tvz_matrix <- tvz_matrix %>% # computing sum of trips per district, mobility rate
left_join(pop_data,
by=c("start_district_name"="Gemeinde_n")) %>%
select(start_district_name, end_district_name, count, pop) %>%
group_by(start_district_name) %>%
mutate(totalCount = sum(count),
rate = sum(count) / pop)
tvz_matrix_joined <- tvz_matrix %>% #add the destination geometry
left_join(districts,
by=c("end_district_name"="Gemeinde_n")) %>%
select(start_district_name, end_district_name, count, geometry) %>%
st_as_sf() %>%
st_transform(USETHISCRS)
tvz_matrix_filtered <- tvz_matrix_joined[0,]
trips_filtered <- trips
View(tvz_matrix_filtered)
View(tvz_matrix_joined)
View(tvz_matrix_filtered)
View(tvz_matrix_joined)
tvz_matrix_joined <- tvz_matrix %>% #add the destination geometry
left_join(districts,
by=c("end_district_name"="Gemeinde_n")) %>%
select(start_district_name, end_district_name, count, pop, totalCount, rate, geometry) %>%
st_as_sf() %>%
st_transform(USETHISCRS)
View(tvz_matrix_joined)
tvz_matrix_filtered <- tvz_matrix_joined[0,]
trips_filtered <- trips
View(tvz_matrix_filtered)
runApp('finalterm_shinyapp.r')
#### MODALSPLIT PLOT ####
plot_modalsplit <- plotModalSplitPieChart(trips)
#### WAITTIME PLOT ####
plot_waittime <- plotAverageTravelWait(trips)
#### SHINY UI ####
ui <- fluidPage(
titlePanel("DataScience finalterm"),
sidebarLayout(
position = "right",
sidebarPanel(plotOutput(outputId = "plot_modalsplit"),
verbatimTextOutput("info")),
mainPanel(leafletOutput("map"),
verbatimTextOutput("legend")))
)
#### SHINY SERVER ####
server <- function(input, output) {
output$map <- renderLeaflet(map) # render leaflet map
output$plot_modalsplit <-  renderPlot({
if(is_null(input$map_shape_click$id)) {
plotModalSplitPieChart(trips)
} else {
plotModalSplitPieChart(trips %>% filter(start_district_name == input$map_shape_click$id))
}
})
output$info <- renderText({
paste0("selected district: ", input$map_shape_click$id)
})
observeEvent(input$map_shape_click, {  # observe polygon clicks
polygon_name <- input$map_shape_click$id  # get the clicked polygon's id
print(paste0("Origin polygon is: ", polygon_name))
tvz_matrix_filtered <- tvz_matrix_joined[tvz_matrix_joined$start_district_name == polygon_name, ] # filter data for map based on polygon name
tvz_matrix_filtered <- tvz_matrix_filtered %>%
mutate(labels = paste0(round(count), " Wege"))
bins <- seq(min(tvz_matrix_filtered$count, tvz_matrix_filtered$count),    # create bins for colorpal
max(tvz_matrix_filtered$count, tvz_matrix_filtered$count),
by = (max(tvz_matrix_filtered$count, tvz_matrix_filtered$count) -
min(tvz_matrix_filtered$count, tvz_matrix_filtered$count)) / 7)
pal <- colorBin("Purples",                                       # custom bin pal
domain = tvz_matrix_filtered$count,
bins = bins)
palQ <- colorQuantile(palette = "YlOrRd",                          # quantile pal
domain = tvz_matrix_filtered$count[tvz_matrix_filtered$count != 0])
leafletProxy("map") %>%                                         # update the app with the filtered data
clearShapes() %>%                                             # remove existing selection
addPolygons(data = districts,                                       # add polygons according to selection
layerId = ~Gemeinde_n,
color = "#000000",
weight = 2,
fillOpacity = 0,
noClip = T
) %>%
addPolygons(data = tvz_matrix_filtered,
layerId = ~end_district_name,
fillColor = ~palQ(count),
highlightOptions = highlightOptions(
color = "red",
bringToFront = T),
label = ~labels,
color = "black",
weight = 1,
fillOpacity = 0.5,
noClip = T
)%>%
addLegend(
position = "bottomleft",
values = tvz_matrix_filtered$count,
title = "Legende Bruder",
pal=palQ
)
})
}
#### RUN SHINY APP ####
shinyApp(ui, server)
#### MODALSPLIT PLOT ####
plot_modalsplit <- plotModalSplitPieChart(trips)
#### WAITTIME PLOT ####
plot_waittime <- plotAverageTravelWait(trips)
#### SHINY UI ####
ui <- fluidPage(
titlePanel("DataScience finalterm"),
sidebarLayout(
position = "right",
sidebarPanel(plotOutput(outputId = "plot_modalsplit"),
verbatimTextOutput("info")),
mainPanel(leafletOutput("map"),
verbatimTextOutput("legend")))
)
#### SHINY SERVER ####
server <- function(input, output) {
output$map <- renderLeaflet(map) # render leaflet map
output$plot_modalsplit <-  renderPlot({
if(is_null(input$map_shape_click$id)) {
plotModalSplitPieChart(trips)
} else {
plotModalSplitPieChart(trips %>% filter(start_district_name == input$map_shape_click$id))
}
})
output$info <- renderText({
paste0("selected district: ", input$map_shape_click$id)
})
observeEvent(input$map_shape_click, {  # observe polygon clicks
polygon_name <- input$map_shape_click$id  # get the clicked polygon's id
print(paste0("Origin polygon is: ", polygon_name))
tvz_matrix_filtered <- tvz_matrix_joined[tvz_matrix_joined$start_district_name == polygon_name, ] # filter data for map based on polygon name
tvz_matrix_filtered <- tvz_matrix_filtered %>%
mutate(labels = paste0(round(count), " Wege"))
bins <- seq(min(tvz_matrix_filtered$count, tvz_matrix_filtered$count),    # create bins for colorpal
max(tvz_matrix_filtered$count, tvz_matrix_filtered$count),
by = (max(tvz_matrix_filtered$count, tvz_matrix_filtered$count) -
min(tvz_matrix_filtered$count, tvz_matrix_filtered$count)) / 7)
pal <- colorBin("Purples",                                       # custom bin pal
domain = tvz_matrix_filtered$count,
bins = bins)
palQ <- colorQuantile(palette = "YlOrRd",                          # quantile pal
domain = tvz_matrix_filtered$count[tvz_matrix_filtered$count != 0])
leafletProxy("map") %>%                                         # update the app with the filtered data
clearShapes() %>%                                             # remove existing selection
addPolygons(data = districts,                                       # add polygons according to selection
layerId = ~Gemeinde_n,
color = "#000000",
weight = 2,
fillOpacity = 0,
noClip = T
) %>%
addPolygons(data = tvz_matrix_filtered,
layerId = ~end_district_name,
fillColor = ~palQ(count),
highlightOptions = highlightOptions(
color = "red",
bringToFront = T),
label = ~labels,
color = "black",
weight = 1,
fillOpacity = 0.5,
noClip = T
)%>%
addLegend(
position = "bottomleft",
values = tvz_matrix_filtered$count,
title = "Legende Bruder",
pal=palQ
)
})
}
#### RUN SHINY APP ####
shinyApp(ui, server)
#### MODALSPLIT PLOT ####
plot_modalsplit <- plotModalSplitPieChart(trips)
#### WAITTIME PLOT ####
plot_waittime <- plotAverageTravelWait(trips)
#### SHINY UI ####
ui <- fluidPage(
titlePanel("DataScience finalterm"),
sidebarLayout(
position = "right",
sidebarPanel(plotOutput(outputId = "plot_modalsplit"),
verbatimTextOutput("info")),
mainPanel(leafletOutput("map"),
verbatimTextOutput("legend")))
)
#### SHINY SERVER ####
server <- function(input, output) {
output$map <- renderLeaflet(map) # render leaflet map
output$plot_modalsplit <-  renderPlot({
if(is_null(input$map_shape_click$id)) {
plotModalSplitPieChart(trips)
} else {
plotModalSplitPieChart(trips %>% filter(start_district_name == input$map_shape_click$id))
}
})
output$info <- renderText({
paste0("selected district: ", input$map_shape_click$id)
})
observeEvent(input$map_shape_click, {  # observe polygon clicks
polygon_name <- input$map_shape_click$id  # get the clicked polygon's id
print(paste0("Origin polygon is: ", polygon_name))
tvz_matrix_filtered <- tvz_matrix_joined[tvz_matrix_joined$start_district_name == polygon_name, ] # filter data for map based on polygon name
tvz_matrix_filtered <- tvz_matrix_filtered %>%
mutate(labels = paste0(round(count), " Wege"))
bins <- seq(min(tvz_matrix_filtered$count, tvz_matrix_filtered$count),    # create bins for colorpal
max(tvz_matrix_filtered$count, tvz_matrix_filtered$count),
by = (max(tvz_matrix_filtered$count, tvz_matrix_filtered$count) -
min(tvz_matrix_filtered$count, tvz_matrix_filtered$count)) / 7)
pal <- colorBin("Purples",                                       # custom bin pal
domain = tvz_matrix_filtered$count,
bins = bins)
palQ <- colorQuantile(palette = "YlOrRd",                          # quantile pal
domain = tvz_matrix_filtered$count[tvz_matrix_filtered$count != 0])
leafletProxy("map") %>%                                         # update the app with the filtered data
clearShapes() %>%                                             # remove existing selection
addPolygons(data = districts,                                       # add polygons according to selection
layerId = ~Gemeinde_n,
color = "#000000",
weight = 2,
fillOpacity = 0,
noClip = T
) %>%
addPolygons(data = tvz_matrix_filtered,
layerId = ~end_district_name,
fillColor = ~palQ(count),
highlightOptions = highlightOptions(
color = "red",
bringToFront = T),
label = ~labels,
color = "black",
weight = 1,
fillOpacity = 0.5,
noClip = T
)%>%
addLegend(
position = "bottomleft",
values = tvz_matrix_filtered$count,
title = "Legende Bruder",
pal=palQ
)
})
}
#### RUN SHINY APP ####
shinyApp(ui, server)
#### MODALSPLIT PLOT ####
plot_modalsplit <- plotModalSplitPieChart(trips)
#### WAITTIME PLOT ####
plot_waittime <- plotAverageTravelWait(trips)
#### SHINY UI ####
ui <- fluidPage(
titlePanel("DataScience finalterm"),
sidebarLayout(
position = "right",
sidebarPanel(plotOutput(outputId = "plot_modalsplit"),
verbatimTextOutput("info")),
mainPanel(leafletOutput("map"),
verbatimTextOutput("legend")))
)
#### SHINY SERVER ####
server <- function(input, output) {
output$map <- renderLeaflet(map) # render leaflet map
output$plot_modalsplit <-  renderPlot({
if(is_null(input$map_shape_click$id)) {
plotModalSplitPieChart(trips)
} else {
plotModalSplitPieChart(trips %>% filter(start_district_name == input$map_shape_click$id))
}
})
output$info <- renderText({
paste0("selected district: ", input$map_shape_click$id)
})
observeEvent(input$map_shape_click, {  # observe polygon clicks
polygon_name <- input$map_shape_click$id  # get the clicked polygon's id
print(paste0("Origin polygon is: ", polygon_name))
tvz_matrix_filtered <- tvz_matrix_joined[tvz_matrix_joined$start_district_name == polygon_name, ] # filter data for map based on polygon name
tvz_matrix_filtered <- tvz_matrix_filtered %>%
mutate(labels = paste0(round(count), " Wega"))
bins <- seq(min(tvz_matrix_filtered$count, tvz_matrix_filtered$count),    # create bins for colorpal
max(tvz_matrix_filtered$count, tvz_matrix_filtered$count),
by = (max(tvz_matrix_filtered$count, tvz_matrix_filtered$count) -
min(tvz_matrix_filtered$count, tvz_matrix_filtered$count)) / 7)
pal <- colorBin("Purples",                                       # custom bin pal
domain = tvz_matrix_filtered$count,
bins = bins)
palQ <- colorQuantile(palette = "YlOrRd",                          # quantile pal
domain = tvz_matrix_filtered$count[tvz_matrix_filtered$count != 0])
leafletProxy("map") %>%                                         # update the app with the filtered data
clearShapes() %>%                                             # remove existing selection
addPolygons(data = districts,                                       # add polygons according to selection
layerId = ~Gemeinde_n,
color = "#000000",
weight = 2,
fillOpacity = 0,
noClip = T
) %>%
addPolygons(data = tvz_matrix_filtered,
layerId = ~end_district_name,
fillColor = ~palQ(count),
highlightOptions = highlightOptions(
color = "red",
bringToFront = T),
label = ~labels,
color = "black",
weight = 1,
fillOpacity = 0.5,
noClip = T
)%>%
addLegend(
position = "bottomleft",
values = tvz_matrix_filtered$count,
title = "Legende Bruder",
pal=palQ
)
})
}
#### RUN SHINY APP ####
shinyApp(ui, server)
#### MODALSPLIT PLOT ####
plot_modalsplit <- plotModalSplitPieChart(trips)
#### WAITTIME PLOT ####
plot_waittime <- plotAverageTravelWait(trips)
#### SHINY UI ####
ui <- fluidPage(
titlePanel("DataScience finalterm"),
sidebarLayout(
position = "right",
sidebarPanel(plotOutput(outputId = "plot_modalsplit"),
verbatimTextOutput("info")),
mainPanel(leafletOutput("map"),
verbatimTextOutput("legend")))
)
#### SHINY SERVER ####
server <- function(input, output) {
output$map <- renderLeaflet(map) # render leaflet map
output$plot_modalsplit <-  renderPlot({
if(is_null(input$map_shape_click$id)) {
plotModalSplitPieChart(trips)
} else {
plotModalSplitPieChart(trips %>% filter(start_district_name == input$map_shape_click$id))
}
})
output$info <- renderText({
paste0("selected district: ", input$map_shape_click$id)
})
observeEvent(input$map_shape_click, {  # observe polygon clicks
polygon_name <- input$map_shape_click$id  # get the clicked polygon's id
print(paste0("Origin polygon is: ", polygon_name))
tvz_matrix_filtered <- tvz_matrix_joined[tvz_matrix_joined$start_district_name == polygon_name, ] # filter data for map based on polygon name
tvz_matrix_filtered <- tvz_matrix_filtered %>%
mutate(labels = paste0(round(count), " Wega"))
bins <- seq(min(tvz_matrix_filtered$count, tvz_matrix_filtered$count),    # create bins for colorpal
max(tvz_matrix_filtered$count, tvz_matrix_filtered$count),
by = (max(tvz_matrix_filtered$count, tvz_matrix_filtered$count) -
min(tvz_matrix_filtered$count, tvz_matrix_filtered$count)) / 7)
pal <- colorBin("Purples",                                       # custom bin pal
domain = tvz_matrix_filtered$count,
bins = bins)
palQ <- colorQuantile(palette = "YlOrRd",                          # quantile pal
domain = tvz_matrix_filtered$count[tvz_matrix_filtered$count != 0])
leafletProxy("map") %>%                                         # update the app with the filtered data
clearShapes() %>%                                             # remove existing selection
addPolygons(data = districts,                                       # add polygons according to selection
layerId = ~Gemeinde_n,
color = "#000000",
weight = 2,
fillOpacity = 0,
noClip = T
) %>%
addPolygons(data = tvz_matrix_filtered,
layerId = ~end_district_name,
fillColor = ~palQ(count),
highlightOptions = highlightOptions(
color = "red",
bringToFront = T),
label = ~labels,
color = "black",
weight = 1,
fillOpacity = 0.5,
noClip = T
)%>%
addLegend(
position = "bottomleft",
values = tvz_matrix_filtered$count,
title = "Legende Bruder",
pal=palQ
)
})
}
#### RUN SHINY APP ####
shinyApp(ui, server)
#### MODALSPLIT PLOT ####
plot_modalsplit <- plotModalSplitPieChart(trips)
#### WAITTIME PLOT ####
plot_waittime <- plotAverageTravelWait(trips)
#### SHINY UI ####
ui <- fluidPage(
titlePanel("DataScience finalterm"),
sidebarLayout(
position = "right",
sidebarPanel(plotOutput(outputId = "plot_modalsplit"),
verbatimTextOutput("info")),
mainPanel(leafletOutput("map"),
verbatimTextOutput("legend")))
)
#### SHINY SERVER ####
server <- function(input, output) {
output$map <- renderLeaflet(map) # render leaflet map
output$plot_modalsplit <-  renderPlot({
if(is_null(input$map_shape_click$id)) {
plotModalSplitPieChart(trips)
} else {
plotModalSplitPieChart(trips %>% filter(start_district_name == input$map_shape_click$id))
}
})
output$info <- renderText({
paste0("selected district: ", input$map_shape_click$id)
})
observeEvent(input$map_shape_click, {  # observe polygon clicks
polygon_name <- input$map_shape_click$id  # get the clicked polygon's id
print(paste0("Origin polygon is: ", polygon_name))
tvz_matrix_filtered <- tvz_matrix_joined[tvz_matrix_joined$start_district_name == polygon_name, ] # filter data for map based on polygon name
tvz_matrix_filtered <- tvz_matrix_filtered %>%
mutate(labels = paste0(round(count), " Wege"))
bins <- seq(min(tvz_matrix_filtered$count, tvz_matrix_filtered$count),    # create bins for colorpal
max(tvz_matrix_filtered$count, tvz_matrix_filtered$count),
by = (max(tvz_matrix_filtered$count, tvz_matrix_filtered$count) -
min(tvz_matrix_filtered$count, tvz_matrix_filtered$count)) / 7)
pal <- colorBin("Purples",                                       # custom bin pal
domain = tvz_matrix_filtered$count,
bins = bins)
palQ <- colorQuantile(palette = "YlOrRd",                          # quantile pal
domain = tvz_matrix_filtered$count[tvz_matrix_filtered$count != 0])
leafletProxy("map") %>%                                         # update the app with the filtered data
clearShapes() %>%                                             # remove existing selection
addPolygons(data = districts,                                       # add polygons according to selection
layerId = ~Gemeinde_n,
color = "#000000",
weight = 2,
fillOpacity = 0,
noClip = T
) %>%
addPolygons(data = tvz_matrix_filtered,
layerId = ~end_district_name,
fillColor = ~palQ(count),
highlightOptions = highlightOptions(
color = "red",
bringToFront = T),
label = ~labels,
color = "black",
weight = 1,
fillOpacity = 0.5,
noClip = T
)%>%
addLegend(
position = "bottomleft",
values = tvz_matrix_filtered$count,
title = "Legende Bruder",
pal=palQ
)
})
}
#### RUN SHINY APP ####
shinyApp(ui, server)
